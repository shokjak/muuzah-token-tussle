/**
 * Muuzah - Reddit Devvit Backend
 * Copy this file to src/main.tsx in your Devvit project
 */

import { Devvit, useState, useAsync } from '@devvit/public-api';

Devvit.configure({
  redditAPI: true,
  redis: true,
});

const REDIS_KEYS = {
  MATCHMAKING_QUEUE: 'muuzah:matchmaking_queue',
  LEADERBOARD: 'muuzah:leaderboard',
  GAME_PREFIX: 'muuzah:game:',
  USER_GAMES_PREFIX: 'muuzah:user_games:',
};

interface GameState {
  gameId: string;
  player1Id: string;
  player2Id: string;
  player1Username: string;
  player2Username: string;
  player1Grid: string;
  player2Grid: string;
  player1Lives: number;
  player2Lives: number;
  player1Score: number;
  player2Score: number;
  player1SetupComplete: boolean;
  player2SetupComplete: boolean;
  currentTurnUserId: string | null;
  shapeValues: string;
  colorMultipliers: string;
  winnerId: string | null;
  winReason: string | null;
  createdAt: number;
  lastMoveAt: number;
}

Devvit.addCustomPostType({
  name: 'Muuzah Game',
  height: 'tall',
  render: (context) => {
    const [webviewVisible, setWebviewVisible] = useState(false);

    // Synchronously handle messages from webview
    const onMessage = (msg: any) => {
      // Handle async operations inside
      (async () => {
        console.log('[Backend] Received message:', JSON.stringify(msg).substring(0, 200));
        
        const type = msg?.type;
        const payload = msg?.payload;

        if (type === 'INIT') {
          console.log('[Backend] Processing INIT');
          try {
            const user = await context.reddit.getCurrentUser();
            const userData = user ? { id: user.id, username: user.username } : null;
            console.log('[Backend] Sending user data:', userData?.username);
            context.ui.webView.postMessage('game-webview', {
              type: 'GAME_STATE_UPDATE',
              payload: { currentUser: userData, gameState: null },
            });
          } catch (e) {
            console.error('[Backend] INIT error:', e);
          }
          return;
        }

        if (type === 'FIND_MATCH') {
          const user = await context.reddit.getCurrentUser();
          if (user) {
            await handleFindMatch(context, { id: user.id, username: user.username });
          }
          return;
        }

        if (type === 'SUBMIT_SETUP') {
          const user = await context.reddit.getCurrentUser();
          if (user) {
            await handleSubmitSetup(context, { id: user.id, username: user.username }, payload?.grid);
          }
          return;
        }

        if (type === 'ATTACK') {
          const user = await context.reddit.getCurrentUser();
          if (user) {
            await handleAttack(context, { id: user.id, username: user.username }, payload?.x, payload?.y);
          }
          return;
        }

        if (type === 'GET_LEADERBOARD') {
          await handleGetLeaderboard(context);
          return;
        }
      })();
    };

    if (!webviewVisible) {
      return (
        <vstack height="100%" width="100%" alignment="center middle" gap="medium" backgroundColor="#1a1a2e">
          <text size="xxlarge" weight="bold" color="#FF4500">ðŸŽ® MUUZAH</text>
          <text size="medium" color="#cccccc">Battleship meets Mastermind</text>
          <spacer size="medium" />
          <button appearance="primary" onPress={() => setWebviewVisible(true)}>
            Play Now
          </button>
        </vstack>
      );
    }

    return (
      <vstack height="100%" width="100%">
        <webview
          id="game-webview"
          url="index.html"
          width="100%"
          height="100%"
          onMessage={onMessage}
        />
      </vstack>
    );
  },
});

async function handleFindMatch(context: any, user: { id: string; username: string }) {
  const redis = context.redis;
  const waitingPlayer = await redis.lPop(REDIS_KEYS.MATCHMAKING_QUEUE);
  
  if (waitingPlayer && waitingPlayer !== user.id) {
    const waitingUser = JSON.parse(waitingPlayer);
    const gameId = `game_${Date.now()}`;
    const shapeValues = generateRandomShapeValues();
    const colorMultipliers = generateColorMultipliers();
    
    const gameState: GameState = {
      gameId,
      player1Id: waitingUser.id,
      player2Id: user.id,
      player1Username: waitingUser.username,
      player2Username: user.username,
      player1Grid: '[]',
      player2Grid: '[]',
      player1Lives: 3,
      player2Lives: 3,
      player1Score: 0,
      player2Score: 0,
      player1SetupComplete: false,
      player2SetupComplete: false,
      currentTurnUserId: null,
      shapeValues: JSON.stringify(shapeValues),
      colorMultipliers: JSON.stringify(colorMultipliers),
      winnerId: null,
      winReason: null,
      createdAt: Date.now(),
      lastMoveAt: Date.now(),
    };
    
    await redis.set(REDIS_KEYS.GAME_PREFIX + gameId, JSON.stringify(gameState));
    await redis.set(REDIS_KEYS.USER_GAMES_PREFIX + user.id, gameId);
    await redis.set(REDIS_KEYS.USER_GAMES_PREFIX + waitingUser.id, gameId);
    
    context.ui.webView.postMessage('game-webview', {
      type: 'MATCH_FOUND',
      payload: { gameId, opponent: waitingUser, youArePlayer: 2, shapeValues, colorMultipliers },
    });
  } else {
    await redis.rPush(REDIS_KEYS.MATCHMAKING_QUEUE, JSON.stringify({ id: user.id, username: user.username }));
    context.ui.webView.postMessage('game-webview', {
      type: 'WAITING_FOR_MATCH',
      payload: {},
    });
  }
}

async function handleSubmitSetup(context: any, user: { id: string }, grid: any) {
  const redis = context.redis;
  const gameId = await redis.get(REDIS_KEYS.USER_GAMES_PREFIX + user.id);
  if (!gameId) return;
  
  const gameData = await redis.get(REDIS_KEYS.GAME_PREFIX + gameId);
  if (!gameData) return;
  
  const game: GameState = JSON.parse(gameData);
  
  if (game.player1Id === user.id) {
    game.player1Grid = JSON.stringify(grid);
    game.player1SetupComplete = true;
  } else {
    game.player2Grid = JSON.stringify(grid);
    game.player2SetupComplete = true;
  }
  
  if (game.player1SetupComplete && game.player2SetupComplete) {
    game.currentTurnUserId = game.player1Id;
  }
  
  await redis.set(REDIS_KEYS.GAME_PREFIX + gameId, JSON.stringify(game));
  
  context.ui.webView.postMessage('game-webview', {
    type: 'SETUP_COMPLETE',
    payload: { bothReady: game.player1SetupComplete && game.player2SetupComplete },
  });
}

async function handleAttack(context: any, user: { id: string }, x: number, y: number) {
  const redis = context.redis;
  const gameId = await redis.get(REDIS_KEYS.USER_GAMES_PREFIX + user.id);
  if (!gameId) return;
  
  const gameData = await redis.get(REDIS_KEYS.GAME_PREFIX + gameId);
  if (!gameData) return;
  
  const game: GameState = JSON.parse(gameData);
  if (game.currentTurnUserId !== user.id) return;
  
  const isPlayer1 = game.player1Id === user.id;
  const opponentGrid = JSON.parse(isPlayer1 ? game.player2Grid : game.player1Grid);
  const cell = opponentGrid[y]?.[x];
  if (!cell || cell.isRevealed) return;
  
  cell.isRevealed = true;
  
  let result: 'hit' | 'miss' | 'bomb' = 'miss';
  let points = 0;
  
  if (cell.isBomb) {
    result = 'bomb';
    if (isPlayer1) game.player1Lives -= 1;
    else game.player2Lives -= 1;
  } else if (cell.token) {
    result = 'hit';
    const shapeValues = JSON.parse(game.shapeValues);
    const colorMultipliers = JSON.parse(game.colorMultipliers);
    points = Math.round(shapeValues[cell.token.shape] * colorMultipliers[cell.token.color]);
    if (isPlayer1) game.player1Score += points;
    else game.player2Score += points;
  }
  
  if (isPlayer1) game.player2Grid = JSON.stringify(opponentGrid);
  else game.player1Grid = JSON.stringify(opponentGrid);
  
  const attackerLives = isPlayer1 ? game.player1Lives : game.player2Lives;
  if (attackerLives <= 0) {
    game.winnerId = isPlayer1 ? game.player2Id : game.player1Id;
    game.winReason = 'sudden-death';
  } else if (allTokensRevealed(opponentGrid)) {
    game.winnerId = game.player1Score >= game.player2Score ? game.player1Id : game.player2Id;
    game.winReason = 'score';
  }
  
  if (!game.winnerId) {
    game.currentTurnUserId = isPlayer1 ? game.player2Id : game.player1Id;
  }
  
  game.lastMoveAt = Date.now();
  await redis.set(REDIS_KEYS.GAME_PREFIX + gameId, JSON.stringify(game));
  
  if (game.winnerId) {
    await updateLeaderboard(redis, game);
  }
  
  context.ui.webView.postMessage('game-webview', {
    type: 'ATTACK_RESULT',
    payload: { x, y, result, token: cell.token, points, gameState: game },
  });
}

async function handleGetLeaderboard(context: any) {
  const redis = context.redis;
  const entries = await redis.zRange(REDIS_KEYS.LEADERBOARD, 0, 9, { by: 'score', reverse: true });
  
  const leaderboard = entries.map((entry: any, index: number) => ({
    rank: index + 1,
    username: entry.member,
    score: entry.score,
    wins: 0,
    gamesPlayed: 0,
  }));
  
  context.ui.webView.postMessage('game-webview', {
    type: 'LEADERBOARD_DATA',
    payload: leaderboard,
  });
}

async function updateLeaderboard(redis: any, game: GameState) {
  const winnerScore = game.player1Id === game.winnerId ? game.player1Score : game.player2Score;
  const winnerUsername = game.player1Id === game.winnerId ? game.player1Username : game.player2Username;
  await redis.zIncrBy(REDIS_KEYS.LEADERBOARD, winnerUsername, winnerScore);
}

function generateRandomShapeValues() {
  const values = [10, 25, 50, 100];
  const shuffled = [...values].sort(() => Math.random() - 0.5);
  return { circle: shuffled[0], square: shuffled[1], triangle: shuffled[2], star: shuffled[3] };
}

function generateColorMultipliers() {
  const multipliers = [1, 1.5, 2, 2.5];
  const shuffled = [...multipliers].sort(() => Math.random() - 0.5);
  return { red: shuffled[0], blue: shuffled[1], green: shuffled[2], yellow: shuffled[3] };
}

function allTokensRevealed(grid: any[][]): boolean {
  return grid.flat().every((cell) => !cell.token || cell.isRevealed);
}

Devvit.addMenuItem({
  label: 'Create Muuzah Game',
  location: 'subreddit',
  onPress: async (event, context) => {
    const subreddit = await context.reddit.getCurrentSubreddit();
    await context.reddit.submitPost({
      title: 'ðŸŽ® MUUZAH - Battleship meets Mastermind!',
      subredditName: subreddit.name,
      preview: (
        <vstack height="100%" width="100%" alignment="center middle">
          <text size="large">Loading Muuzah...</text>
        </vstack>
      ),
    });
    context.ui.showToast('Muuzah game created!');
  },
});

export default Devvit;
